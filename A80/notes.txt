BROM is at address 0, at least after boot1 started.

Boot code is loaded at address 0x10000 (SRAM_A1).

From kernel headers, which matches observations:

SUNXI_BROM0_N_PBASE                       0x00000000
SUNXI_BROM0_N_SIZE                        0x00008000
SUNXI_SRAM_A1_PBASE                       0x00010000
SUNXI_SRAM_A1_SIZE                        0x0000a000

Not sure what BROM1 is. Range overlaps with BROM0

SUNXI_BROM1_S_PBASE                       0x00000000
SUNXI_BROM1_S_SIZE                        0x00010000

Haven't tested any of the following yet

SUNXI_SRAM_A2_PBASE                       0x08100000
SUNXI_SRAM_A2_SIZE                        0x00028000
SUNXI_SRAM_B_PBASE                        0x00020000
SUNXI_SRAM_B_SIZE                         0x00040000
SUNXI_SRAM_C_PBASE                        0x01d00000
SUNXI_SRAM_C_SIZE                         0x00100000
SUNXI_DRAM_PBASE                          0x20000000 /* 0x20000000 ~ 0x220000000(size: 8G) */
SUNXI_GPU_PBASE                           0x02000000
SUNXI_GPU_SIZE                            0x01000000

Boot headers seem to be mostly the same as before

All structs available in kernel & u-boot headers.

typedef struct _Boot_file_head {
    __u32 jump_instruction;
    __u8 magic[8];
    __u32 check_sum;
    __u32 length;
    __u32 pub_head_size;
    __u8 pub_head_vsn[4];
    __u8 file_head_vsn[4];
    __u8 Boot_vsn[4];
    __u8 eGON_vsn[4];
    __u8 platform[8];
} boot_file_head_t;

struct _boot0_private_head_t {
    __u32 prvt_head_size;
    char prvt_head_vsn[4];
    boot_dram_para_t dram_para;
    __s32 uart_port;
    normal_gpio_cfg uart_ctrl[2];
    __s32 enable_jtag;
    normal_gpio_cfg jtag_gpio[5];
    normal_gpio_cfg storage_gpio[32];
    char storage_data[256];
}

struct _boot_dram_para_t {
    __u32 dram_baseaddr;
    __u32 dram_clk;
    __u32 dram_type;
    __u32 dram_rank_num;
    __u32 dram_chip_density;
    __u32 dram_io_width;
    __u32 dram_bus_width;
    __u32 dram_cas;
    __u32 dram_zq;
    __u32 dram_odt_en;
    __u32 dram_size;
    __u32 dram_tpr0;
    __u32 dram_tpr1;
    __u32 dram_tpr2;
    __u32 dram_tpr3;
    __u32 dram_tpr4;
    __u32 dram_tpr5;
    __u32 dram_emr1;
    __u32 dram_emr2;
    __u32 dram_emr3;
}

struct _normal_gpio_cfg {
    __u8 port;
    __u8 port_num;
    __u8 mul_sel;
    __u8 pull;
    __u8 drv_level;
    __u8 data;
    __u8 reserved[2];
}

struct _boot1_private_head_t {
    __u32 prvt_head_size;
    __u8 prvt_head_vsn[4];
    __s32 uart_port;
    normal_gpio_cfg uart_ctrl[2];
    boot_dram_para_t dram_para;
    char script_buf[32768];
    boot_core_para_t core_para;
    __s32 twi_port;
    normal_gpio_cfg twi_ctrl[2];
    __s32 debug_enable;
    __s32 hold_key_min;
    __s32 hold_key_max;
    __u32 work_mode;
    __u32 storage_type;
    normal_gpio_cfg storage_gpio[32];
    char storage_data[256];
}

struct _boot_core_para_t {
    __u32 user_set_clock;
    __u32 user_set_core_vol;
    __u32 vol_threshold;
}


struct _boot_sdcard_info_t {
    __s32 card_ctrl_num;
    __s32 boot_offset;
    __s32 card_no[4];
    __s32 speed_mode[4];
    __s32 line_sel[4];
    __s32 line_count[4];
}

typedef struct
{
	unsigned int		ChannelCnt;
	unsigned int        ChipCnt;                            //the count of the total nand flash chips are currently connecting on the CE pin
    unsigned int       ChipConnectInfo;                    //chip connect information, bit == 1 means there is a chip connecting on the CE pin
	unsigned int		RbCnt;
	unsigned int		RbConnectInfo;						//the connect  information of the all rb  chips are connected
    unsigned int        RbConnectMode;						//the rb connect  mode
	unsigned int        BankCntPerChip;                     //the count of the banks in one nand chip, multiple banks can support Inter-Leave
    unsigned int        DieCntPerChip;                      //the count of the dies in one nand chip, block management is based on Die
    unsigned int        PlaneCntPerDie;                     //the count of planes in one die, multiple planes can support multi-plane operation
    unsigned int        SectorCntPerPage;                   //the count of sectors in one single physic page, one sector is 0.5k
    unsigned int       PageCntPerPhyBlk;                   //the count of physic pages in one physic block
    unsigned int       BlkCntPerDie;                       //the count of the physic blocks in one die, include valid block and invalid block
    unsigned int       OperationOpt;                       //the mask of the operation types which current nand flash can support support
    unsigned int        FrequencePar;                       //the parameter of the hardware access clock, based on 'MHz'
    unsigned int        EccMode;                            //the Ecc Mode for the nand flash chip, 0: bch-16, 1:bch-28, 2:bch_32
    unsigned char       NandChipId[8];                      //the nand chip id of current connecting nand chip
    unsigned int       ValidBlkRatio;                      //the ratio of the valid physical blocks, based on 1024
	unsigned int 		good_block_ratio;					//good block ratio get from hwscan
	unsigned int		ReadRetryType;						//the read retry type
	unsigned int       DDRType;
	unsigned int		Reserved[32];
}boot_nand_para_t0;

